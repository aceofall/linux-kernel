# ARM10C 61주차 후기
##### 일시 : 2014.07.05 (61주차)
##### 모임명 : NAVER개발자커뮤니티지원_IAMROOT.ORG_10차ARM-C
##### 장소 : 토즈 타워점
##### 장소지원 : NAVER 개발자 커뮤니티 지원 프로그램
##### 참여인원 :  5명

## 스터디 진도 : 
 - mm_init()을 계속 분석합니다.
 - start_kernel()-> mm_init()->kmem_cache_init()->bootstrap()분석중

## main.c::mm_init()
```
static void __init mm_init(void)
{
	page_cgroup_init_flatmem(); // null function
	mem_init();
	// bootmem으로 관리하던 메모리를 buddy로 이관.
	// 각 section 메모리 크기를 출력.
	
	// mm/Makefile 에서 CONFIG_SLUB 설정으로 slub.c 로 jump
	kmem_cache_init();
```
// mm/Makefile 에서 CONFIG_SLUB 설정으로 slub.c 로 jump
> 	kmem_cache_init();

## slub.c::kmem_cache_init()
```
void __init kmem_cache_init(void)
{
...
	kmem_cache = bootstrap(&boot_kmem_cache);
```
> 	kmem_cache = bootstrap(&boot_kmem_cache);

## slub.c::bootstrap()
// ARM10C 20140628
// struct kmem_cache * static_cache: &boot_kmem_cache
```
static struct kmem_cache * __init bootstrap(struct kmem_cache *static_cache)
{
	int node;

	// kmem_cache: &boot_kmem_cache, GFP_NOWAIT: 0
	// kmem_cache_zalloc(&boot_kmem_cache, GFP_NOWAIT: 0):
	// UNMOVABLE인 page (boot_kmem_cache)의 object의 시작 virtual address
	// kmem_cache: &boot_kmem_cache_node, GFP_NOWAIT: 0
	// kmem_cache_zalloc(&boot_kmem_cache_node, GFP_NOWAIT: 0):
	// UNMOVABLE인 page (boot_kmem_cache_node)의 object의 시작 virtual address
	struct kmem_cache *s = kmem_cache_zalloc(kmem_cache, GFP_NOWAIT);
	// s: UNMOVABLE인 page (boot_kmem_cache)의 object의 시작 virtual address

	// s: UNMOVABLE인 page (boot_kmem_cache)의 object의 시작 virtual address,
	// static_cache: &boot_kmem_cache,
	// kmem_cache->object_size: boot_kmem_cache.object_size: 116
	memcpy(s, static_cache, kmem_cache->object_size);
	// boot_kmem_cache에 세팅된 멤버 필드 값을 전부 할당 받은 object로 복사함

// 2014/06/28 종료
// 2014/07/05 시작
    // s: UNMOVABLE인 page (boot_kmem_cache)의 object의 시작 virtual address,
	// smp_processor_id(): 0
	__flush_cpu_slab(s, smp_processor_id());
```
// s: UNMOVABLE인 page (boot_kmem_cache)의 object의 시작 virtual address,
// smp_processor_id(): 0
> __flush_cpu_slab(s, smp_processor_id());

## slub.c::__flush_cpu_slab()
// *s: UNMOVABLE인 page (boot_kmem_cache)의 object의 시작 virtual address,
// cpu: smp_processor_id(): 0
```
static inline void __flush_cpu_slab(struct kmem_cache *s, int cpu)
{
	// s->cpu_slab: (&boot_kmem_cache 용 object 주소)->cpu_slab: 0xc0502d10, cpu: 0
	// per_cpu_ptr(0xc0502d10, 0):
	// (&boot_kmem_cache 용 object 주소)->cpu_slab + (pcpu_unit_offsets[0] + __per_cpu_start에서의pcpu_base_addr의 옵셋)
	struct kmem_cache_cpu *c = per_cpu_ptr(s->cpu_slab, cpu);
	// c: (&boot_kmem_cache 용 object 주소)->cpu_slab + (pcpu_unit_offsets[0] + __per_cpu_start에서의pcpu_base_addr의 옵셋)
	
	// c: (&boot_kmem_cache 용 object 주소)->cpu_slab + (pcpu_unit_offsets[0] + __per_cpu_start에서의pcpu_base_addr의 옵셋)
	if (likely(c)) {
		// c->page: ((&boot_kmem_cache 용 object 주소)->cpu_slab + (pcpu_unit_offsets[0] + __per_cpu_start에서의pcpu_base_addr의 옵셋))->page:
		// UNMOVABLE인 page (boot_kmem_cache)
		if (c->page)
			// s: UNMOVABLE인 page (boot_kmem_cache)의 object의 시작 virtual address,
			// c: (&boot_kmem_cache 용 object 주소)->cpu_slab + (pcpu_unit_offsets[0] + __per_cpu_start에서의pcpu_base_addr의 옵셋)
			flush_slab(s, c);
```
// s: UNMOVABLE인 page (boot_kmem_cache)의 object의 시작 virtual address,
// c: (&boot_kmem_cache 용 object 주소)->cpu_slab + (pcpu_unit_offsets[0] + __per_cpu_start에서의pcpu_base_addr의 옵셋)
> flush_slab(s, c);

## slub.c::flush_slab()
// *s: UNMOVABLE인 page (boot_kmem_cache)의 object의 시작 virtual address,
// *c: (&boot_kmem_cache 용 object 주소)->cpu_slab + (pcpu_unit_offsets[0] + __per_cpu_start에서의pcpu_base_addr의 옵셋)
```
static inline void flush_slab(struct kmem_cache *s, struct kmem_cache_cpu *c)
{
	// s: UNMOVABLE인 page (boot_kmem_cache)의 object의 시작 virtual address,
	// CPUSLAB_FLUSH: 13
	stat(s, CPUSLAB_FLUSH);

	// s: UNMOVABLE인 page (boot_kmem_cache)의 object의 시작 virtual address,
	// c->page: ((&boot_kmem_cache 용 object 주소)->cpu_slab + (pcpu_unit_offsets[0] + __per_cpu_start에서의pcpu_base_addr의 옵셋))->page:
	// UNMOVABLE인 page (boot_kmem_cache),
	// c->freelist: ((&boot_kmem_cache 용 object 주소)->cpu_slab + (pcpu_unit_offsets[0] + __per_cpu_start에서의pcpu_base_addr의 옵셋))->freelist:
	// UNMOVABLE인 page (boot_kmem_cache)의 시작 virtual address + 128
	deactivate_slab(s, c->page, c->freelist);
```
// s: UNMOVABLE인 page (boot_kmem_cache)의 object의 시작 virtual address,
// c->page: ((&boot_kmem_cache 용 object 주소)->cpu_slab + (pcpu_unit_offsets[0] + __per_cpu_start에서의pcpu_base_addr의 옵셋))->page:
// UNMOVABLE인 page (boot_kmem_cache),
// c->freelist: ((&boot_kmem_cache 용 object 주소)->cpu_slab + (pcpu_unit_offsets[0] + __per_cpu_start에서의pcpu_base_addr의 옵셋))->freelist:
// UNMOVABLE인 page (boot_kmem_cache)의 시작 virtual address + 128
> deactivate_slab(s, c->page, c->freelist);

## slub.c::deactivate_slab()
// ARM10C 20140705
// s: UNMOVABLE인 page (boot_kmem_cache)의 object의 시작 virtual address,
// c->page: ((&boot_kmem_cache 용 object 주소)->cpu_slab + (pcpu_unit_offsets[0] + __per_cpu_start에서의pcpu_base_addr의 옵셋))->page:
//          UNMOVABLE인 page (boot_kmem_cache),
// c->freelist: ((&boot_kmem_cache 용 object 주소)->cpu_slab + (pcpu_unit_offsets[0] + __per_cpu_start에서의pcpu_base_addr의 옵셋))->freelist:
//          UNMOVABLE인 page (boot_kmem_cache)의 시작 virtual address + 128
```
static void deactivate_slab(struct kmem_cache *s, struct page *page,
				void *freelist)
{
	enum slab_modes { M_NONE, M_PARTIAL, M_FULL, M_FREE };
	// M_NONE: 0, M_PARTIAL: 1, M_FULL: 2, M_FREE:3

	struct kmem_cache_node *n = get_node(s, page_to_nid(page));
```

* page_to_nid(page)
* // get_node(UNMOVABLE인 page (boot_kmem_cache)의 object의 시작 virtual address, 0):
* // (&boot_kmem_cache 용 object 주소)->node[0]
```
// ARM10C 20140705
static inline int page_to_nid(const struct page *page)
{
	// NODES_PGSHIFT: 0, NODES_MASK: 3
	return (page->flags >> NODES_PGSHIFT) & NODES_MASK;
}
```

```
	struct kmem_cache_node *n = get_node(s, page_to_nid(page));
```	
// s: UNMOVABLE인 page (boot_kmem_cache)의 object의 시작 virtual address,
// page: UNMOVABLE인 page (boot_kmem_cache)
// page_to_nid(UNMOVABLE인 page (boot_kmem_cache)): 0
// get_node(UNMOVABLE인 page (boot_kmem_cache)의 object의 시작 virtual address, 0):
// (&boot_kmem_cache 용 object 주소)->node[0]
> struct kmem_cache_node *n = get_node(s, page_to_nid(page));

## slub.c::get_node()
// ARM10C 20140705
// s: UNMOVABLE인 page (boot_kmem_cache)의 object의 시작 virtual address, 0
```
static inline struct kmem_cache_node *get_node(struct kmem_cache *s, int node)
{
	// node: 0, s->node: (&boot_kmem_cache 용 object 주소)->node[0]
	return s->node[node];
	// return (&boot_kmem_cache 용 object 주소)->node[0]
}
```
> get_node(s, page_to_nid(page));
// return (&boot_kmem_cache 용 object 주소)->node[0]

## slub.c::deactivate_slab()
> get_node(s, page_to_nid(page));
// return (&boot_kmem_cache 용 object 주소)->node[0]
```
static void deactivate_slab(struct kmem_cache *s, struct page *page,
				void *freelist)
{
...
    struct kmem_cache_node *n = get_node(s, page_to_nid(page));
	// n: (&boot_kmem_cache 용 object 주소)->node[0]

	int lock = 0;
	// lock: 0
	enum slab_modes l = M_NONE, m = M_NONE;
	// l: M_NONE: 0,  m: M_NONE: 0
	void *nextfree;
	int tail = DEACTIVATE_TO_HEAD;
	// tail: DEACTIVATE_TO_HEAD: 15
	struct page new;
	struct page old;

	// page->freelist: (UNMOVABLE인 page (boot_kmem_cache))->freelist: NULL
	if (page->freelist) {
		stat(s, DEACTIVATE_REMOTE_FREES);
		tail = DEACTIVATE_TO_TAIL;
	}
	// s: UNMOVABLE인 page (boot_kmem_cache)의 object의 시작 virtual address,
	// freelist: UNMOVABLE인 page (boot_kmem_cache)의 시작 virtual address + 128
	// get_freepointer(UNMOVABLE인 page (boot_kmem_cache)의 object의 시작 virtual address,
	// UNMOVABLE인 page (boot_kmem_cache)의 시작 virtual address + 128):
	// UNMOVABLE인 page (boot_kmem_cache)의 시작 virtual address + 256
	// nextfree: UNMOVABLE인 page (boot_kmem_cache)의 시작 virtual address + 256
	while (freelist && (nextfree = get_freepointer(s, freelist))) {
		void *prior;
		unsigned long counters;

		// [loop 1] freelist: UNMOVABLE인 page (boot_kmem_cache)의 시작 virtual address + 128
		// [loop 1] nextfree: UNMOVABLE인 page (boot_kmem_cache)의 시작 virtual address + 256

		do {
			// [loop 1] page->freelist: NULL
			prior = page->freelist;
			// [loop 1] prior: NULL

			// [loop 1] page->counters: (UNMOVABLE인 page (boot_kmem_cache))->counters: 0x80200020
			counters = page->counters;
			// [loop 1] counters: 0x80200020

			// [loop 1] s: UNMOVABLE인 page (boot_kmem_cache)의 object의 시작 virtual address,
			// [loop 1] freelist: UNMOVABLE인 page (boot_kmem_cache)의 시작 virtual address + 128,
			// [loop 1] prior: NULL
			set_freepointer(s, freelist, prior);
			// [loop 1] freelist: UNMOVABLE인 page (boot_kmem_cache)의 시작 virtual address + 128: NULL
			// [loop 1] UNMOVABLE인 page (boot_kmem_cache)의 시작 virtual address + 128 의 다음 object를 가리키는 주소의 값을
			// [loop 1] NULL로 세팅

			// [loop 1] counters: 0x80200020
			new.counters = counters;
			// [loop 1] new.counters: 0x80200020

			// [loop 1] new.inuse: 32, new.counters: 0x80200020
			new.inuse--;
			// [loop 1] new.inuse: 31, new.counters: 0x8020001f

			// [loop 1] new.frozen: 1
			VM_BUG_ON(!new.frozen);

			// [loop 1] s: UNMOVABLE인 page (boot_kmem_cache)의 object의 시작 virtual address,
			// [loop 1] page: UNMOVABLE인 page (boot_kmem_cache),
			// [loop 1] prior: NULL, counters: 0x80200020,
			// [loop 1] freelist: UNMOVABLE인 page (boot_kmem_cache)의 시작 virtual address + 128,
			// [loop 1] new.counters: 0x8020001f,
			// [loop 1] "drain percpu freelist"
			// [loop 1] __cmpxchg_double_slab(UNMOVABLE인 page (boot_kmem_cache)의 object의 시작 virtual address,
			// [loop 1] UNMOVABLE인 page (boot_kmem_cache), NULL, 0x80200020, UNMOVABLE인 page (boot_kmem_cache)의 시작 virtual address + 128,
			// [loop 1] 0x8020001f, "drain percpu freelist"): 1
			// [loop 1] UNMOVABLE인 page (boot_kmem_cache)의 필드 맴버 값 변경
			// [loop 1] (UNMOVABLE인 page (boot_kmem_cache))->freelist: UNMOVABLE인 page (boot_kmem_cache)의 시작 virtual address + 128
			// [loop 1] (UNMOVABLE인 page (boot_kmem_cache))->counters: 0x8020001f
		} while (!__cmpxchg_double_slab(s, page,
			prior, counters,
			freelist, new.counters,
			"drain percpu freelist"));
```
1번째 루프
// freelist: UNMOVABLE인 page (boot_kmem_cache)의 시작 virtual address + 128
// nextfree: UNMOVABLE인 page (boot_kmem_cache)의 시작 virtual address + 256
> __cmpxchg_double_slab(s, page,
>			prior, counters,
>			freelist, new.counters,
>			"drain percpu freelist"));

## slub.c::__cmpxchg_double_slab()
// ARM10C 20140705
// s: UNMOVABLE인 page (boot_kmem_cache)의 object의 시작 virtual address,
// page: UNMOVABLE인 page (boot_kmem_cache), prior: NULL, counters: 0x80200020
// freelist: UNMOVABLE인 page (boot_kmem_cache)의 시작 virtual address + 128
// new.counters: 0x8020001f, "drain percpu freelist"
```
static inline bool __cmpxchg_double_slab(struct kmem_cache *s, struct page *page,
		void *freelist_old, unsigned long counters_old,
		void *freelist_new, unsigned long counters_new,
		const char *n)
{
	// irqs_disabled(): 1
	VM_BUG_ON(!irqs_disabled());

// CONFIG_HAVE_CMPXCHG_DOUBLE=n, CONFIG_HAVE_ALIGNED_STRUCT_PAGE=n
#if defined(CONFIG_HAVE_CMPXCHG_DOUBLE) && \
    defined(CONFIG_HAVE_ALIGNED_STRUCT_PAGE)
	if (s->flags & __CMPXCHG_DOUBLE) {
		if (cmpxchg_double(&page->freelist, &page->counters,
			freelist_old, counters_old,
			freelist_new, counters_new))
		return 1;
	} else
#endif
	{
		// page: UNMOVABLE인 page (boot_kmem_cache)
		slab_lock(page);
		// preempt count 증가 후 memory barrier 적용

		// page: UNMOVABLE인 page (boot_kmem_cache)
		// page->freelist: (UNMOVABLE인 page (boot_kmem_cache))->freelist: NULL, freelist_old: NULL,
		// page->counters: 0x80200020, counters_old: 0x80200020
		if (page->freelist == freelist_old &&
					page->counters == counters_old) {
			// freelist_new: UNMOVABLE인 page (boot_kmem_cache)의 시작 virtual address + 128
			page->freelist = freelist_new;
			// page->freelist: UNMOVABLE인 page (boot_kmem_cache)의 시작 virtual address + 128

			// page->counters: 0x80200020, counters_new: 0x8020001f
			page->counters = counters_new;
			// page->counters: 0x8020001f

			// page: UNMOVABLE인 page (boot_kmem_cache)
			slab_unlock(page);
			// (MIGRATE_UNMOVABLE인 page(boot_kmem_cache))->flags 의 bit 0을 클리어함
			// dmb(ish)를 사용하여 공유 자원 (MIGRATE_UNMOVABLE인 page)->flags 값을 갱신
			// memory barrier 적용 후 preempt count 감소 시킴

			return 1;
			// return 1
		}
		slab_unlock(page);
	}

	cpu_relax();
	stat(s, CMPXCHG_DOUBLE_FAIL);

#ifdef SLUB_DEBUG_CMPXCHG
	printk(KERN_INFO "%s %s: cmpxchg double redo ", n, s->name);
#endif

	return 0;
}
```
// return 1

## slub.c::deactivate_slab()
1번째 루프
// freelist: UNMOVABLE인 page (boot_kmem_cache)의 시작 virtual address + 128
// nextfree: UNMOVABLE인 page (boot_kmem_cache)의 시작 virtual address + 256

// return 1
> 	while (freelist && (nextfree = get_freepointer(s, freelist))) {

```

# 스터디 로그
```
133cada..6d65c2e  master     -> origin/master
Updating 133cada..6d65c2e
Fast-forward
include/linux/fault-inject.h |   1 +
include/linux/kernel.h       |   1 +
include/linux/list.h         |   6 +
include/linux/lockdep.h      |   1 +
include/linux/memcontrol.h   |   4 +
include/linux/mm.h           |   1 +
include/linux/nodemask.h     |   1 +
include/linux/percpu.h       |  91 ++++++++
include/linux/slab.h         |   5 +
include/linux/slub_def.h     |   1 +
include/linux/smp.h          |   1 +
include/linux/spinlock.h     |   1 +
mm/slab.h                    |   1 +
mm/slab_common.c             |   7 +-
mm/slub.c                    | 534 ++++++++++++++++++++++++++++++++++++++++++-
15 files changed, 641 insertions(+), 15 deletions(-)
```				

```
12edc2f..03f2c9d  master     -> origin/master
Updating 12edc2f..03f2c9d
Fast-forward
 include/linux/percpu-defs.h |   3 +-
 include/linux/percpu.h      |  26 +++++++-
 mm/slub.c                   | 144 ++++++++++++++++++++++++++------------------
 3 files changed, 109 insertions(+), 64 deletions(-)
```
