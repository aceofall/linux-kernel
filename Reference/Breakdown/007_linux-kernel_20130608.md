# 7주차 Study Note (2013/06/08)

## Status
 - 인원: 20명
 - 장소: [토즈 강남점(NHN지원)] (http://www.toz.co.kr/branch/main/index.htm?id=10)
 - 진도: [Arm System Developer's Guide] (http://kangcom.com/sub/view.asp?sku=200502190006&mcd=571) (~Ch.09, 인터럽트 처리 방법 진행 중) <br  /> <br  />

## Notice
 - 기 선정된 Chapter 위주로 진행 (Ch.3은 개인이 각자 보고 다음시간에 질문 시간 갖자! <br  /> <br  />

## Issues (Ongoing)
- [x] **1. 메모리 타이밍과 리프레시 비율의 의미?** 
[[#42]](https://github.com/arm10c/linux-stable/issues/42)
    > 메모리 타이밍은 작업을 수행할때 걸리는 시간을 램 클럭을 기준으로 대기 시간을 정하는 옵션이다. 보통 칩에서 제공하는 값이 있어서 그 값을 바탕으로 타이밍을 정한다. 

    > 리프레시 비율은 데이터 값이 지워지지 않도록 주기적으로 신호를 주어서 처리하는 것이다. 
    > DRAM cell은 Row, Column, Bank로 이루어져 있으며 이것이 address 특정 bit와 대응한다. 
    > 중간에서 Row Buffer를 통해 항상 access하며, bank는 동시에 여는 Row Buffer의 수를 의미한다.
    > (Ref.:[Memory timings] (http://en.wikipedia.org/wiki/SDRAM_latency))

  <br />
- [x] **2. 부호 확장기의 역할은?** 
[[#43]](https://github.com/arm10c/linux-stable/issues/43)
    > Signed 값 지정시에 사용한다.
Unsigned 정수의 경우 0 extension, Signed 정수의 경우 MSB extension 이다.

  <br />
- [x] **3. "register" 지시어를 피해야 하는 이유는 무엇인가?** 
[[#44]](https://github.com/arm10c/linux-stable/issues/44)
    > stack의 cycle수 때문에 그렇다. 유저 입장에서는 사용하지 않는 것이 현명하다.
    > register를 통해 강제로 register를 지정하면 compiler입장에서 GPR 후보군이 작아지므로 최적화에 방해가 된다.
  
  <br />
- [x] **4. Scratch register란?** 
[[#45]](https://github.com/arm10c/linux-stable/issues/45)
    > 범용 목적으로 사용하는 register이다.
  
  <br />
- [x] **5. 코드가 작은 함수의 경우 compiler가 이를 알고 inline화 시키는데, "작은"함수의 기준이 어떻게 되는가?** 
[[#46]](https://github.com/arm10c/linux-stable/issues/46)
    > 결론만 얘기하면 정해진 rule은 없다.
    > compiler 제작자마다 version마다 다를 수 있으며, inline 결정 관련 인자는 아래와 같다.

    > - 함수의 크기 및 함수가 호출되는 횟수 (e.g.: 해당 함수가 1곳에서만 call되는 경우 or 1줄짜리 함수인 경우)
    > - 현재 최적화 수준 (O2또는 O3 이상)
    > - 속도(-Otime)가 최적화 대상인지 아니면 크기(-Ospace)가 최적화 대상인지 여부 (Otime일 때 inline)
    > - 함수에 외부 또는 정적 연결 중 어느 것이 있는지 여부
    > - 함수에 포함된 매개변수의 수
    > - 함수 반환 값 사용 여부
  
  <br />
- [x] **6. inline함수는 일반 C 함수처럼 header파일을 공유해서 사용하는가?** 
[[#47]](https://github.com/arm10c/linux-stable/issues/47)
    > 그렇다. 보통은 다른 C 함수처럼 사용한다.

  <br />
- [x] **7. exception이나 interrupt 시 복귀 주소가 상이한 이유는 무엇인가?** 
[[#48]](https://github.com/arm10c/linux-stable/issues/48)
    > 오늘 스터디중 이해가 잘 안되는 부분이 있었습니다.
    > 그런데 방금 책 보다가 해결이 되어 공유합니다. 사실과 다른 것이 있다면 과감하게 댓글 달아주세요.^^

    > ![image](https://cloud.githubusercontent.com/assets/4760134/14403676/0a76abe2-fe9c-11e5-89bf-c9553f51906c.png)
    > [표 9.4] 링크 레지스터 기반의 익셉션 복귀 주소

    > 질문은 'IRQ가 발생하면 왜 링크 레지스터에 -4를 빼는가?' 였습니다.
    > 제가 찾은 답은 이렇습니다.
    > 이해를 돕기 위해 ADD, SUB, MOV가 파이프라인에 들어있다고 가정할께요. 

    >     | Fetch (LR)  | Decode (LR-4)  | Execution (LR-8) |
    >     |  ADD        | SUB            | MOV              |

    > 파이프라인 동작 특성으로 인해 실행 단계에서 PC는 항상 명령어 주소에 8을 더한 값을 가리킵니다. (34page 인용)
    > 지금 이 순간에는 PC가 ADD의 주소를 가리키고 있습니다.

    > IRQ 익셉션이 발생하면 하드웨어가 일단 MOV까지는 실행시킵니다.
    > 그런 다음 링크 레지스터에 PC를 넣는 작업까지 해 줍니다.

    >    r14_irq = PC 

    > 아 그런데 MOV까지 실행 했으니까 SUB로 돌아가야 하는데 링크 레지스터가 엉뚱한 곳을 가리키네요.
    > 보정해 줍시다. 

    >   r14_irq = r14_irq - 4

    > 이렇게 해서 왜 링크 레지스터에 -4를 하는지 밝혀 졌습니다.

    > SWI와 Undefined Exception는 왜 LR을 그대로 쓸까요?
    > 마찬가지로 예를 들어 볼께요.

    >     | Fetch (LR)  | Decode (LR-4)  | Execution (LR-8) |
    >     |  ADD        | SWI            | MOV              |

    > Software Interrupt가 발생하는 순간의 모습은 이렇습니다.
    > 바로 Decode에 SWI가 걸렸을 때 입니다.
    > 앞에서 본 것 보다 한 클럭 일찍 예외가 발생하네요.

    > 지금 PC는 ADD의 주소를 가리키고 있으니까
    > 앞에서와 같이 -4를 해버리면 무한 인터럽트에 빠질 태니까
    > LR 레지스터를 그냥 써도 되겠네요. :)

    > Undefined Exception도 Decode 단계에서 예외가 발생하나 봅니다.
    > 어떤 명령어인지 찾아보다가 "이보게 내 사전에 그 명령어는 없네."하고 발생하는 거니까요.

    > Data Abort 익셉션이 발생하면 LR에 -8을 빼서 보정합니다.
    > 익셉션을 발생시킨 명령어를 가리키는 것인데 아마도 디버깅을 위해서가 아닌가 싶습니다.

    >     | Fetch (LR)  | Decode (LR-4)  | Execution (LR-8) |
    >     |  ADD        | SUB            | LDR              |


  <br />
- [x] **8. Thumb모드의 장점은 무엇인가?** 
[[#25]](https://github.com/arm10c/linux-stable/issues/25)
    > Code의 사이즈를 줄일 수 있고, 시스템 구성상 호환성을 보장한다. 또한 code의 사이즈가 줄기 때문에 cache hit 율이 올라가고 그에따른 성능향상을 보장 받는다. ARM모드 대비 70%로 code 압축 효과가 있고, 130% 성능 개선이 있다. (Ref.: Embedded Recipes) 

    > 어떠한 제약 때문에 16비트 폭의 메모리를 사용하는 경우 Thumb모드가 훨씬 빠릅니다. 16 비트 폭의 메모리를 사용하는 경우도 ARM모드를 사용할 수 있습니다. 하지만 ARM명령을 두번에 걸쳐 읽어야 하기 때문에 Thumb모드보다 느립니다.

  <br />
- [x] **9. ARM pipeline에서 각 stage에서 소요되는 cycle 수는 보통 1 cycle인가?** 
[[#26]](https://github.com/arm10c/linux-stable/issues/26)
    > 보통은 1cycle이다.

  <br />
- [x] **10. 5stage 이상 pipeline에서 memory와 write-back stage에서 소요되는 cycle 수가 같을까?** 
[[#27]](https://github.com/arm10c/linux-stable/issues/27)
    > 둘은 메모리와 레지스터로 하드웨어적인 특성이 다르다. 5단 pipeline의 경우 대부분 프로세서 속도 500MHz이하에서 L1 cache를 1cycle로 구현 가능하다. 이경우 register와 동일하게 1cycle access time을 갖는다.

    > 그러나 memory stage가 꼭 L1 hit된 경우만 있지는 않다. cache miss, page miss 등의 경우도 발생한다. (심지어 Reg. File의 경우 1clock을 2phase로 나누어 write, read 처리하여 write한 data를 동일 clock에 읽어내는 경우도 있다.) 
    
    > 1GHz 이상의 프로세서는 대부분 L1 cache latency가 2cycle 이상이며 이경우 memory stage가 2개 이상으로 늘어난다.

  <br />
- [x] **11. ARM pipeline의 forwarding 기능은 어느 architecture version 부터 적용이 되었는가?** 
[[#28]](https://github.com/arm10c/linux-stable/issues/28)
    > 아마 5단계 이상부터 사용되었을 것이다. 추가 조사가 필요하다.
:sos:

  <br />
- [x] **12. pipeline의 multiple issue는 어떻게 처리 가능한가?** 
[[#29]](https://github.com/arm10c/linux-stable/issues/29)
    > pipeline은 Front-End와 Back-End부분으로 나뉘며, 각 부분에는 [Reservation Station](https://en.wikipedia.org/wiki/Reservation_station)과 [ROB(ReOrder Buffer)](http://en.wikipedia.org/wiki/Re-order_buffer)를 통해 처리된다.
![image](https://cloud.githubusercontent.com/assets/4760134/14227229/bb5224fa-f933-11e5-85c6-4546ce0c1abd.png)

  <br />
- [x] **13. Cortex 계열의 ARM 버전은 몇이라고 보면 되는가?** 
[[#30]](https://github.com/arm10c/linux-stable/issues/30)
    > Cortex는 A, M, R 계열로 나뉘며, 현재 study하고 있는 Exynos5420은 ARMv7이다.

    > ![image](https://cloud.githubusercontent.com/assets/4760134/14227283/dfdd8106-f934-11e5-932f-199f2a60a6a4.png)

  <br />
- [x] **14. TCM은 무엇인가?** 
[[#31]](https://github.com/arm10c/linux-stable/issues/31)
    > TCM(Tightly Coupled Memory)로 임베디드 쪽에서 critical한 이슈를 다룰 때 사용한다. 

    > 자동차 분야를 예로들면, 당장 급한 task는 cache에 쓰고 하고 할 시간이 없다. 그런 경우 cache를 안거치고 수사이클 이내에 직접 TCM에 접근하여 처리한다.

    > ![image](https://cloud.githubusercontent.com/assets/4760134/14227358/78eab6f6-f936-11e5-81cb-08a73e45f771.png)

  <br />
- [x] **15. co-processor의 경우 instruction을 어떻게 처리하는가?** 
[[#32]](https://github.com/arm10c/linux-stable/issues/32)
    > Undefined exception을 발생시키고, 분기하여 처리한다.

  <br />  
- [x] **16. Thumb Mode에서도 다른 mode로 변경이 가능한가?** 
[[#33]](https://github.com/arm10c/linux-stable/issues/33)
    > Thumb명령어 bx, blx 를 이용하여 ARM state로 변경될 수 있습니다. 

    > 또한 Thumb명령어인 swi 를 사용하면 인터럽트가 발생하여 ARM 모드로 진입하게 됩니다.

  <br />  
- [x] **17. Loop-unrolling이 어떤 역할을 하는가?** 
[[#34]](https://github.com/arm10c/linux-stable/issues/34)
    > Loop를 적당하게 풀면, pipeline의 gain을 얻는 수 있는데, 이런 작업을 하는 과정이다. 
보통은 profiling을 통해 hot spot을 찾고, gain을 얻을 수 있는지 판단에 의해 작업한다.

    > ![image](https://cloud.githubusercontent.com/assets/4760134/14227410/cb191fb6-f937-11e5-9c96-204a64df384a.png)
    > ![image](https://cloud.githubusercontent.com/assets/4760134/14227467/6de84b1c-f939-11e5-8903-bfa5fe7247d7.png)

  <br />
- [x] **18. 자동 inline 옵션은 compiler의 어떤 optimization level부터 가능한가?** 
[[#35]](https://github.com/arm10c/linux-stable/issues/35)
    > GCC의 경우 O3옵션 사용하면 가능하다.
    > ```
    >	                       Included in Level
    >    Optimization	       -O1  -O2  -Os  -O3
    >    inline-functions        X	  X    X    O
    > ```
    >    
    > (Ref.: [KLDP wiki](https://wiki.kldp.org/wiki.php/GccOptimizationOptions))

  <br />
- [x] **19. Point aliasing은 무엇인가?** 
[[#36]](https://github.com/arm10c/linux-stable/issues/36)
    > 서로 다른 이름을 가진 pointer가 같은 주소를 지정하는 경우를 말함. 이경우 thread unsafe하기 때문에 warning발생
    > ![image](https://cloud.githubusercontent.com/assets/4760134/14227538/3d57cd36-f93b-11e5-9f93-05ede223bb56.png)

  <br />
- [x] **20. ARM의 주소지정방식 중 IA-DB, FD-EA가 의미하는 것은?** 
[[#37]](https://github.com/arm10c/linux-stable/issues/37)
    > 여러개의 데이타를 load store 하는 명령어인 ldm, stm 과 조합하여 사용합니다. 

    > stack에 저장할 때 특히 신경써야 할 부분입니다. ARM 에서는 기본적으로 Full-Descending 스택 정책을 사용합니다. 따라서 스택에 저장할 때는 먼저 스택포인터를 줄이고, 그 다음에 저장을 합니다. 
    
    > 스택에서 읽을 때는 반대로 먼저 읽고 스택포인터를 증가시킵니다. (그렇게 약속이 되어있습니다) 


    > 이때 사용하는 명령어 짝이 stmdb (store multiple decrease before), ldmia (load multiple increase after) 입니다. 다른 방법으로는 stmfd, ldmfd 를 사용해도 컴파일러가 알아서 stmdb, ldmia로 바꾸어 컴파일해줍니다. 
    
    > 마찬가지로 push, pop을 쓰면 알아서 FD 스택이라고 가정하고 컴파일 해줍니다. Empty, Ascending/Descending, Increase/Decrease, Before/After는 아래를 통해 이해.
    
    > ![image](https://cloud.githubusercontent.com/assets/4760134/14227620/b6b13cfc-f93c-11e5-9f6b-fec006732ee3.png)

    > ※ 동일 명령어   <br />
    > :LDMDA = LDMFA  <br />
    > :LDMDB = LDMEA  <br /> 
    > :LDMIA = LDMFD = LDM = POP  <br /> 
    > :LDMIB = LDMED  <br />
    > :STMDA = STMED  <br />
    > :STMDB = STMFD = PUSH  <br />
    > :STMIA = STMEA = STM  <br /> 
    > :STMIB = STMFA  <br />
    
  <br />
- [x] **21. 최적화 시, r0~r3 register를 사용하는데, 그 원리가 어떻게 되는가?** 
[[#38]](https://github.com/arm10c/linux-stable/issues/38)
    > 함수의 인자가 int형(4byte)4개를 넘으면 나머지는 스택에 저장됩니다.
    > double처럼 4byte를 넘어갈 경우 복수의 레지스터에 저장되며, 함수의 리턴값은 r0~r1에 저장됩니다. 만약 8byte가 넘을 경우 포인터를 return합니다.

  <br />
- [x] **22. ARM의 어셈블리 명령은 어떻게 기계어 명령으로 변환되는가?** 
[[#39]](https://github.com/arm10c/linux-stable/issues/39)
    > 아래 그림과 같이 일정한 규칙에 의해 변환된다.
![image](https://cloud.githubusercontent.com/assets/4760134/14227655/8e44e36c-f93d-11e5-85fa-af4a6db90225.png)


  <br />
